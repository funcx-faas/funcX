#! groovy

@Library('gcs-build-scripts') _

pipeline {
    agent none
    options {
        buildDiscarder(
            logRotator(
                numToKeepStr: '5',
                artifactNumToKeepStr: '1',
                artifactDaysToKeepStr: '7'
            )
        )
        timeout(time: 3, unit: 'HOURS')
        disableConcurrentBuilds()
    }
    stages {
        stage ("Prep source") {
            agent {label "package_creator"}
            steps {
                script {
                    def scmVars = checkout scm
                    if (env.BRANCH_OR_TAG != null && env.BRANCH_OR_TAG != "") {
                        sh "git checkout ${env.BRANCH_OR_TAG}"
                    }
                    env.BRANCH_NAME = scmVars.GIT_BRANCH.replaceFirst(/^.*origin\//, "")
                    env.TAG_NAME = sh(returnStdout: true, script: "git tag --contains | head -1").trim()
                    env.SOURCE_STASH_NAME = "${UUID.randomUUID()}"
                    echo "env.BRANCH_NAME = ${env.BRANCH_NAME}"
                    sh "git clean -fdx"

//                     dir("compute_endpoint/packaging/") {
//                         sh(script: "make show_vars")
//                         sh(script: "make setup_dist_for_deb setup_dist_for_rpm")
//                         sh "mv dist/ ${env.SOURCE_STASH_NAME}"
//                         stash(name: env.SOURCE_STASH_NAME, includes: "${env.SOURCE_STASH_NAME}/**/*")
//                     }
//
//                     def venv_py = "${env.WORKSPACE}/compute_endpoint/packaging/venv/bin/python"
//                     def py_full_version = sh(script: "'${venv_py}' -c 'import sys; print(\"{}.{}\".format(*sys.version_info))'", returnStdout: true).trim()
//                     def (py_epoch_version, py_major_version) = py_full_version.tokenize(".")
//                     def pkg_version = "not yet set"
//
//                     dir("compute_endpoint/") {
//                         env.PACKAGE_VERSION = sh(script: "${venv_py} setup.py --version", returnStdout: true).trim().replace("-", "~")
//                         echo "pkg_version = ${env.PACKAGE_VERSION}"
//                     }
//                     env.PKG_TARBALL = "globus_compute_endpoint-${env.PACKAGE_VERSION.replace("~", "")}.tar.gz"
//                     env.PREREQS_TARBALL = "globus_compute_endpoint-prereqs-py${py_epoch_version}${py_major_version}-${env.PACKAGE_VERSION}.tar.gz"


                echo "Creating publish-results script"

                def pull = getPullRequest()
                def epic = getClubhouseEpic()
                def branch_name = getBranchName()
                def default_branch = getDefaultBranch()
                def tag = getTag()
                if (branch_name != null && !pull) {
                    // If this is a tag, then Jenkins sets BRANCH_NAME to the tag,
                    // so we need to figure out if this is tag is actually part of
                    // the main branch.
                    def branch_name_is_a_tag = (branch_name == env.TAG_NAME)
                    echo "branch name = ${branch_name}, env.TAG_NAME = ${env.TAG_NAME}, default_branch=${getDefaultBranch()}"
                    def tag_is_on_default_branch = (
                        branch_name_is_a_tag
                        && tagIsOnBranch(env.TAG_NAME, default_branch)
                    )
                    echo "branch_name_is_a_tag = ${branch_name_is_a_tag}, tag_is_on_default_branch=${tag_is_on_default_branch}"

                    if ((! branch_name_is_a_tag) && branch_name != default_branch) {
                        non_default_branch_name = branch_name
                    } else if ((branch_name != null && branch_name == default_branch)
                            || tag_is_on_default_branch) {
                        if (env.STABLE_TAG) {
                            echo "Using stable tag pattern ${env.STABLE_TAG}"
                            echo "Replacing \${PACKAGE_NAME} with ${package_name}"
                            echo "Replacing \${PACKAGE_VERSION} with ${package_version}"
                        } else {
                            echo "Using default stable tag pattern v${package_version}"
                        }
                        def stable_tag = (env.STABLE_TAG
                            ? env.STABLE_TAG.replace('${PACKAGE_NAME}', package_name)
                                .replace('${PACKAGE_VERSION}', package_version)
                            : "v${package_version}"
                        )
                        publish_to_unstable = true

                        if (is_release_candidate(package_version)) {
                            publish_to_testing = true
                        } else if (tag == stable_tag
                                || (tag =~ "^${stable_tag}-\\d+\$").matches()) {
                            publish_to_testing = true
                            publish_to_stable = true
                        }
                    }
                }

                echo "pull           = ${pull}"
                echo "epic           = ${epic}"
                echo "branch_name    = ${branch_name}"
                echo "default_branch = ${default_branch}"
                echo "tag            = ${tag}"
                echo "branch_name_is_a_tag = ${branch_name_is_a_tag}"
                echo "tag_is_on_default_branch = ${tag_is_on_default_branch}"
                echo "---------------"
                echo "publish_to_unstable = ${publish_to_unstable}"
                echo "publish_to_testing  = ${publish_to_testing}"
                echo "publish_to_stable   = ${publish_to_stable}"
                sh "/bin/false"



//
                }
            }
        }
        stage ("Build packages") {
            steps {
                script {
                    lock(resource: 'globus-compute-agent-build') {
                        parallel "debian": {
                            def extra_tarball_map = [
                                prereqs: env.PREREQS_TARBALL
                            ]
                            env.DEB_ARTIFACTS_STASH = buildDebian(
                                env.SOURCE_STASH_NAME,
                                env.PKG_TARBALL,
                                require_gcs5_repo: true,
                                extra_tarball_map: extra_tarball_map
                            )
                        }, "rpm": {
                            env.RPM_ARTIFACTS_STASH = buildMock(
                                env.SOURCE_STASH_NAME,
                                env.PKG_TARBALL,
                                true
                            )
                        }, "failFast": false
                    }
                }
            }
        }
        stage ("Publish packages") {
            agent { label "master" }
            steps {
                script {
                    def stashname = "${UUID.randomUUID()}"

                    dir("artifacts") {
                        if (env.DEB_ARTIFACTS_STASH) {
                            unstash(name: env.DEB_ARTIFACTS_STASH)
                        }
                        if (env.RPM_ARTIFACTS_STASH) {
                            unstash(name: env.RPM_ARTIFACTS_STASH)
                        }

                        stash(name: stashname, includes: "**/*")
                        deleteDir()
                    }
                    publishResults(stashname, "globus-compute-agent",  env.PACKAGE_VERSION, false)
                    deleteDir()
                }
            }
        }
    }
}
